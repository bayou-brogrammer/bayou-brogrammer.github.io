<!DOCTYPE html>
<html lang="en">

<head>
    <title>Exploring Bevy Game of life shader (Part 3) | </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://n16hth4wkk.github.io/style.css">
    <link rel="stylesheet" href="https://n16hth4wkk.github.io/color/red.css">

        <link rel="stylesheet" href="https://n16hth4wkk.github.io/color/background_blue.css">
    
    <link rel="stylesheet" href="https://n16hth4wkk.github.io/font-hack-subset.css">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://n16hth4wkk.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Yendor&#x27;s World
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://n16hth4wkk.github.io">blog</a></li>
            
                <li><a href="https://n16hth4wkk.github.io/tags">tags</a></li>
            
                <li><a href="https://n16hth4wkk.github.io/archive">archive</a></li>
            
                <li><a href="https://n16hth4wkk.github.io/about">about me</a></li>
            
                <li><a href="https://github.com/n16hth4wkk" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://n16hth4wkk.github.io/bevy-gol-explore-part-3/">Exploring Bevy Game of life shader (Part 3)</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2023-05-01
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://n16hth4wkk.github.io/tags/bevy/">#bevy</a>&nbsp;
                <a class="post-tag" href="https://n16hth4wkk.github.io/tags/blog/">#blog</a>&nbsp;
                <a class="post-tag" href="https://n16hth4wkk.github.io/tags/programming/">#programming</a>&nbsp;
                <a class="post-tag" href="https://n16hth4wkk.github.io/tags/rust/">#rust</a>&nbsp;
                <a class="post-tag" href="https://n16hth4wkk.github.io/tags/shader/">#shader</a></span>
    

        
        <div class="post-content">
            <p>It is exciting to finally see some progress after so much boilerplate! Let's change up the color scheme a bit! I like the color red, so let's make the
alive cells red. In our shader, switch the init_pipeline color to the following:</p>
<span id="continue-reading"></span><pre data-lang="glsl" style="background-color:#151515;color:#e8e8d3;" class="language-glsl "><code class="language-glsl" data-lang="glsl"><span>@compute @</span><span style="color:#ffb964;">workgroup_size</span><span>(</span><span style="color:#cf6a4c;">8</span><span>, </span><span style="color:#cf6a4c;">8</span><span>, </span><span style="color:#cf6a4c;">1</span><span>)
</span><span>fn </span><span style="color:#fad07a;">init</span><span>(@</span><span style="color:#ffb964;">builtin</span><span>(global_invocation_id) invocation_id: </span><span style="color:#8fbfdc;">vec3</span><span>&lt;u32&gt;, @</span><span style="color:#ffb964;">builtin</span><span>(num_workgroups) num_workgroups: </span><span style="color:#8fbfdc;">vec3</span><span>&lt;u32&gt;) {
</span><span>    let location = </span><span style="color:#8fbfdc;">vec2</span><span>&lt;i32&gt;(invocation_id.</span><span style="color:#ffb964;">xy</span><span>);
</span><span>
</span><span>    let randomNumber = </span><span style="color:#ffb964;">randomFloat</span><span>(invocation_id.</span><span style="color:#ffb964;">y </span><span>* num_workgroups.</span><span style="color:#ffb964;">x </span><span>+ invocation_id.</span><span style="color:#ffb964;">x</span><span>);
</span><span>    let alive = randomNumber &gt; </span><span style="color:#cf6a4c;">0.9</span><span>;
</span><span>    let color = </span><span style="color:#8fbfdc;">vec4</span><span>&lt;f32&gt;(</span><span style="color:#ffb964;">f32</span><span>(alive), </span><span style="color:#cf6a4c;">0.0</span><span>, </span><span style="color:#cf6a4c;">0.0</span><span>, </span><span style="color:#cf6a4c;">1.0</span><span>); </span><span style="color:#888888;">// NEW
</span><span>
</span><span>    </span><span style="color:#ffb964;">textureStore</span><span>(texture, location, color);
</span><span>}
</span></code></pre>
<p>And you should see something like this:</p>

  <img src="/images/gol_part3_red.png" class="center" />

<p>Very red! Now onto our update pipeline, which makes all this worth it to see the cells move.</p>
<h2 id="update-pipeline">Update Pipeline</h2>
<p>Back in <code>pipeline.rs</code> lets update our match statement within the run function of our node.</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#888888;">// select the pipeline based on the current state
</span><span style="color:#8fbfdc;">match </span><span style="color:#ffb964;">self</span><span>.state {
</span><span>    GameOfLifeState::Loading =&gt; {}
</span><span>    GameOfLifeState::Init =&gt; {
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> init_pipeline = pipeline_cache
</span><span>            .get_compute_pipeline(pipeline.init_pipeline)
</span><span>            .unwrap();
</span><span>        pass.set_pipeline(init_pipeline);
</span><span>        pass.dispatch_workgroups(
</span><span>            </span><span style="color:#7697d6;">SIM_SIZE</span><span>.</span><span style="color:#cf6a4c;">0 </span><span>/ </span><span style="color:#7697d6;">WORKGROUP_SIZE</span><span>,
</span><span>            </span><span style="color:#7697d6;">SIM_SIZE</span><span>.</span><span style="color:#cf6a4c;">1 </span><span>/ </span><span style="color:#7697d6;">WORKGROUP_SIZE</span><span>,
</span><span>            </span><span style="color:#cf6a4c;">1</span><span>,
</span><span>        );
</span><span>    }
</span><span>    GameOfLifeState::Update =&gt; {
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> update_pipeline = pipeline_cache
</span><span>            .get_compute_pipeline(pipeline.update_pipeline)
</span><span>            .unwrap();
</span><span>        pass.set_pipeline(update_pipeline);
</span><span>        pass.dispatch_workgroups(
</span><span>            </span><span style="color:#7697d6;">SIM_SIZE</span><span>.</span><span style="color:#cf6a4c;">0 </span><span>/ </span><span style="color:#7697d6;">WORKGROUP_SIZE</span><span>,
</span><span>            </span><span style="color:#7697d6;">SIM_SIZE</span><span>.</span><span style="color:#cf6a4c;">1 </span><span>/ </span><span style="color:#7697d6;">WORKGROUP_SIZE</span><span>,
</span><span>            </span><span style="color:#cf6a4c;">1</span><span>,
</span><span>        );
</span><span>    }
</span><span>}
</span></code></pre>
<p>It is exactly the same as the init pipeline, we just use the update pipeline instead. That takes care of the rust side of things, now onto the shader.</p>
<h2 id="conway-s-game-of-life">Conway's Game of Life</h2>
<p>The particular bit of cellular automata we are implementing is <code>Conway's Game of Life</code>. The rules are as follows:</p>
<ol>
<li>Any live cell with fewer than two live neighbours dies, as if by underpopulation.</li>
<li>Any live cell with two or three live neighbours lives on to the next generation.</li>
<li>Any live cell with more than three live neighbours dies, as if by overpopulation.</li>
<li>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</li>
</ol>
<p>These rules, which compare the behaviour of the automaton to real life, can be condensed into the following:</p>
<ol>
<li>Any live cell with two or three live neighbours survives.</li>
<li>Any dead cell with three live neighbours becomes a live cell.</li>
<li>All other live cells die in the next generation. Similarly, all other dead cells stay dead.</li>
</ol>
<p>Back in our update fn, lets start by pulling the current location</p>
<pre data-lang="glsl" style="background-color:#151515;color:#e8e8d3;" class="language-glsl "><code class="language-glsl" data-lang="glsl"><span>@compute @</span><span style="color:#ffb964;">workgroup_size</span><span>(</span><span style="color:#cf6a4c;">8</span><span>, </span><span style="color:#cf6a4c;">8</span><span>, </span><span style="color:#cf6a4c;">1</span><span>)
</span><span>fn </span><span style="color:#fad07a;">update</span><span>(@</span><span style="color:#ffb964;">builtin</span><span>(global_invocation_id) invocation_id: </span><span style="color:#8fbfdc;">vec3</span><span>&lt;u32&gt;) {
</span><span>    let location = </span><span style="color:#8fbfdc;">vec2</span><span>&lt;i32&gt;(invocation_id.</span><span style="color:#ffb964;">xy</span><span>);
</span><span>}
</span></code></pre>
<p>Now we need to count the number of alive neighbors, but to do that, we need a way to tell if a cell is alive or dead.
Add the following utility function</p>
<pre data-lang="glsl" style="background-color:#151515;color:#e8e8d3;" class="language-glsl "><code class="language-glsl" data-lang="glsl"><span>...
</span><span>fn </span><span style="color:#fad07a;">is_alive</span><span>(location: </span><span style="color:#8fbfdc;">vec2</span><span>&lt;i32&gt;, offset_x: </span><span style="color:#ffb964;">i32</span><span>, offset_y: </span><span style="color:#ffb964;">i32</span><span>) -&gt; u32 {
</span><span>    let value: </span><span style="color:#8fbfdc;">vec4</span><span>&lt;f32&gt; = </span><span style="color:#ffb964;">textureLoad</span><span>(texture, location + </span><span style="color:#8fbfdc;">vec2</span><span>&lt;i32&gt;(offset_x, offset_y));
</span><span>    </span><span style="color:#8fbfdc;">return </span><span style="color:#ffb964;">u32</span><span>(value.</span><span style="color:#ffb964;">x</span><span>);
</span><span>}
</span><span>...
</span></code></pre>
<p>This function takes in a location, and an offset. We store all our data within the texture itself as colors. (in our instance its red colors for alive <br />
and black for dead). <code>textureLoad</code> loads the color at the given location. We know a cell is alive if the color returned is red, which is a value of 1.0 a <code>x</code></p>
<p>Now that we have a way to tell if a cell is alive, we can move onto counting the neighbors. We need to check the 8 cells surrounding the current cell.
We can acheive this using a simple nested for loop. Here is what I came up with:</p>
<pre data-lang="glsl" style="background-color:#151515;color:#e8e8d3;" class="language-glsl "><code class="language-glsl" data-lang="glsl"><span>fn </span><span style="color:#fad07a;">count_neighbors_simple</span><span>(location: </span><span style="color:#8fbfdc;">vec2</span><span>&lt;i32&gt;) -&gt; u32 {
</span><span>    var result: u32 = </span><span style="color:#cf6a4c;">0u</span><span>;
</span><span>    </span><span style="color:#8fbfdc;">for </span><span>(var x: i32 = -</span><span style="color:#cf6a4c;">1</span><span>; x &lt; </span><span style="color:#cf6a4c;">2</span><span>; x++) {
</span><span>        </span><span style="color:#8fbfdc;">for </span><span>(var y: i32 = -</span><span style="color:#cf6a4c;">1</span><span>; y &lt; </span><span style="color:#cf6a4c;">2</span><span>; y++) {
</span><span>            </span><span style="color:#8fbfdc;">if</span><span> x == </span><span style="color:#cf6a4c;">0 </span><span>&amp;&amp; y == </span><span style="color:#cf6a4c;">0 </span><span>{
</span><span>                </span><span style="color:#8fbfdc;">continue</span><span>;
</span><span>            }
</span><span>
</span><span>            result += </span><span style="color:#ffb964;">is_alive</span><span>(location, x, y); 
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#8fbfdc;">return</span><span> result;
</span><span>}
</span></code></pre>
<p>We take in a location to count the neighbors of, and return the number of alive neighbors by looping through the 8 surrounding cells
and calling our <code>is_alive</code> function. Lets add this to our update function:</p>
<pre data-lang="glsl" style="background-color:#151515;color:#e8e8d3;" class="language-glsl "><code class="language-glsl" data-lang="glsl"><span>@compute @</span><span style="color:#ffb964;">workgroup_size</span><span>(</span><span style="color:#cf6a4c;">8</span><span>, </span><span style="color:#cf6a4c;">8</span><span>, </span><span style="color:#cf6a4c;">1</span><span>)
</span><span>fn </span><span style="color:#fad07a;">update</span><span>(@</span><span style="color:#ffb964;">builtin</span><span>(global_invocation_id) invocation_id: </span><span style="color:#8fbfdc;">vec3</span><span>&lt;u32&gt;) {
</span><span>    let location = </span><span style="color:#8fbfdc;">vec2</span><span>&lt;i32&gt;(invocation_id.</span><span style="color:#ffb964;">xy</span><span>);
</span><span>    let is_alive = </span><span style="color:#8fbfdc;">bool</span><span>(</span><span style="color:#ffb964;">is_alive</span><span>(location, </span><span style="color:#cf6a4c;">0</span><span>, </span><span style="color:#cf6a4c;">0</span><span>));
</span><span>    let num_neighbors = </span><span style="color:#ffb964;">count_neighbors_simple</span><span>(location);
</span><span>}
</span></code></pre>
<p>It is pretty staight forward from here, we just need to implement the rules from above.</p>
<pre data-lang="glsl" style="background-color:#151515;color:#e8e8d3;" class="language-glsl "><code class="language-glsl" data-lang="glsl"><span>...
</span><span>
</span><span>var result: u32 = </span><span style="color:#cf6a4c;">0u</span><span>;
</span><span>
</span><span style="color:#8fbfdc;">if </span><span>(is_alive) { 
</span><span>    result = ((</span><span style="color:#ffb964;">u32</span><span>((num_neighbors) == (</span><span style="color:#cf6a4c;">2u</span><span>))) | (</span><span style="color:#ffb964;">u32</span><span>((num_neighbors) == (</span><span style="color:#cf6a4c;">3u</span><span>)))); 
</span><span>} </span><span style="color:#8fbfdc;">else </span><span>{ 
</span><span>    result = </span><span style="color:#ffb964;">u32</span><span>((num_neighbors) == (</span><span style="color:#cf6a4c;">3u</span><span>)); 
</span><span>}
</span><span>
</span><span>let color = </span><span style="color:#8fbfdc;">vec4</span><span>&lt;f32&gt;(</span><span style="color:#ffb964;">f32</span><span>(result), </span><span style="color:#cf6a4c;">0.0</span><span>, </span><span style="color:#cf6a4c;">0.0</span><span>, </span><span style="color:#cf6a4c;">1.0</span><span>);
</span><span style="color:#ffb964;">textureStore</span><span>(texture, location, color);
</span></code></pre>
<p>If the current cell is alive, we check if it has 2 or 3 neighbors, if it does, it lives on, otherwise it dies. If the current cell is dead,
we check if it has 3 neighbors, if it does, it becomes alive, otherwise it stays dead. Then we store our result as a color in the texture (red in this case).</p>
<blockquote>
<p>Note: I removed the window_fps plugin and <code>FrameTimeDiagnosticsPlugin</code> plugin. It was slowing down my app when running.
I also disabled <code>bevy::window::PresentMode::AutoNoVsync</code> otherwise, the app runs at like 3k fps XD</p>
</blockquote>
<p>Running the app should now show the cells moving around!!! How cool!</p>

  <img src="/images/gol_running.gif" class="center" />

<p>Code can be found on github: <a href="https://github.com/n16hth4wkk/bevy_shader_playground/blob/fb19ddc592691e4e89582a0954f7963eea9300de/sims/game_of_life_sim/src/lib.rs">Part 3</a></p>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://n16hth4wkk.github.io/bevy-gol-explore-part-2/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">Exploring Bevy Game of life shader (Part 2)</span>
                        </a>
                    </span>
                
                
                    <span class="button next">
                        <a href="https://n16hth4wkk.github.io/bevy-gol-explore-part-4/">
                            <span class="button__text">Exploring Bevy Game of life shader (Part 4)</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright copyright--user">© Jacob LeCoq and n16hth4wkk.github.io, 2023. <br><br> Unauthorized use and/or duplication of this material without express and written permission 
from this site’s author and/or owner is strictly prohibited. Excerpts and links may be used, provided that full and clear credit is given to Jacob LeCoq 
and n16hth4wkk.github.io with appropriate and specific direction to the original content </div>
            </div>
    </footer>
    

</div>
</body>

</html>
